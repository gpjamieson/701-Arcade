<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tron Light Cycle Game</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Include the Tone.js library from a CDN for programmatic sound generation -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
    <style>
        body {
            font-family: 'Press Start 2P', cursive;
            background-color: #000000;
            color: #f0f0f0;
            overflow: hidden; /* Prevent scrolling */
        }
        .game-container {
            touch-action: none; /* Disable browser gestures */
        }
        canvas {
            background-color: #000;
            border: 2px solid #00ffff;
            box-shadow: 0 0 25px rgba(0, 255, 255, 0.5), inset 0 0 15px rgba(0, 255, 255, 0.3);
            /* Make canvas responsive */
            max-width: 100%;
            height: auto;
            display: block;
            margin: 0 auto; /* Center the canvas */
        }
        .modal {
            background-color: rgba(0, 0, 0, 0.85);
            border: 1px solid #00ffff;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
            z-index: 100; /* Ensure modal is on top of other elements */
        }
        .text-glow {
            text-shadow: 0 0 5px #fff, 0 0 10px #fff, 0 0 15px #00ffff, 0 0 20px #00ffff;
        }
    </style>
</head>
<body class="flex items-center justify-center h-screen m-0 p-4">

    <div class="text-center w-full max-w-2xl">
        <h1 class="text-4xl md:text-5xl mb-4 text-cyan-300 text-glow">TRON</h1>
        <div class="game-container relative inline-block">
            <canvas id="gameCanvas" width="600" height="400"></canvas>
            
            <!-- Game Info Display -->
            <div id="level" class="absolute top-2 left-4 text-xl text-cyan-300 text-glow">LEVEL: 1</div>
            <div id="opponentsLeft" class="absolute top-2 right-4 text-xl text-red-400 text-glow">OPPONENTS: 1</div>
            <div id="currentScore" class="absolute bottom-2 left-4 text-xl text-yellow-300 text-glow">SCORE: 0</div>
            <div id="highScore" class="absolute bottom-2 right-4 text-xl text-purple-400 text-glow">HIGH: 0</div>
            <div id="playerLives" class="absolute top-8 left-4 text-xl text-green-400 text-glow">LIVES: 3</div>
            
            <!-- Message Modal -->
            <div id="messageModal" class="modal absolute inset-0 flex flex-col items-center justify-center hidden p-4">
                <h2 id="modalTitle" class="text-2xl md:text-4xl mb-4 text-glow"></h2>
                <p id="modalText" class="text-lg md:text-xl mb-6 text-center"></p>
                <button id="modalButton" class="bg-cyan-500 text-gray-900 font-bold px-6 py-3 md:px-8 md:py-4 rounded-lg text-lg md:text-xl hover:bg-cyan-400 focus:outline-none focus:ring-2 focus:ring-cyan-300 transition transform hover:scale-105 active:scale-95">
                    START
                </button>
                <p class="mt-4 text-sm md:text-base text-gray-400">Press Spacebar to continue</p>
            </div>
        </div>
        <p class="mt-4 text-sm md:text-base text-gray-400">Use Arrow Keys to Turn. Be the last one standing.</p>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('gameCanvas');
            const ctx = canvas.getContext('2d');

            const levelElement = document.getElementById('level');
            const opponentsLeftElement = document.getElementById('opponentsLeft');
            const currentScoreElement = document.getElementById('currentScore');
            const highScoreElement = document.getElementById('highScore');
            const playerLivesElement = document.getElementById('playerLives'); // New element for lives
            const messageModal = document.getElementById('messageModal');
            const modalTitle = document.getElementById('modalTitle');
            const modalText = document.getElementById('modalText');
            // The modalButton will be dynamically replaced to handle event listeners cleanly.

            // --- Game Constants ---
            const gridSize = 10;
            let tileCountX; // Will be calculated based on canvas dimensions
            let tileCountY; // Will be calculated based on canvas dimensions

            // --- Game Configuration ---
            // Define levels with increasing speed and number of opponents
            const levels = [
                { speed: 120, opponents: 1, scoreMultiplier: 10 }, // Slower for easier start
                { speed: 110, opponents: 1, scoreMultiplier: 12 },
                { speed: 100, opponents: 2, scoreMultiplier: 15 },
                { speed: 95, opponents: 2, scoreMultiplier: 18 },
                { speed: 90, opponents: 3, scoreMultiplier: 20 },
                { speed: 85, opponents: 3, scoreMultiplier: 25 },
                { speed: 80, opponents: 4, scoreMultiplier: 30 },
            ];
            
            // --- Game State ---
            let player;
            let opponents = [];
            let allTrails = [];
            let currentLevel = 0;
            let gameSpeed;
            let gameInterval;
            let isGameOver = true;
            let currentScore = 0;
            let highScore = 0;
            let playerLives = 3; // Initial number of lives
            let scoreMultiplier = 1; // Multiplier for opponent knockouts
            let levelStartTime = 0; // To track survival time for scoring
            const basePointsPerSecond = 100; // Base points earned per second of survival
            let currentModalCallback = null; // Stores the function to call when modal button/spacebar is pressed

            // --- Sound Effects using Tone.js ---
            // Define individual sound effects using Tone.Synth or Tone.MembraneSynth
            const soundEffects = {
              crash: new Tone.Synth().toDestination(),
              levelUp: new Tone.Synth().toDestination(),
              gameOver: new Tone.Synth().toDestination(),
              start: new Tone.Synth().toDestination(), // Used for game start (original 'turn' sound)
              turn: new Tone.Synth().toDestination(), // Changed 'turn' to a simple Synth for a bass sound
              derezzed: new Tone.Synth().toDestination() // New sound for opponent derezzed
            };

            // Configure specific sound characteristics (volume, in dB)
            soundEffects.turn.volume.value = -15; // Adjusted volume for the new bass 'turn' sound
            soundEffects.crash.volume.value = -5;
            soundEffects.levelUp.volume.value = -8;
            soundEffects.gameOver.volume.value = -7;
            soundEffects.start.volume.value = -10; 
            soundEffects.derezzed.volume.value = -10; // Volume for derezzed sound

            // --- Background Music using Tone.js ---
            let highSynth;
            let melodySynth;
            let bassSynth;
            let highPart;   // Declare globally to manage disposal
            let melodyPart; // Declare globally to manage disposal
            let bassPart;   // Declare globally to manage disposal

            function initializeBackgroundMusic() {
                // Dispose previous synths AND parts if they exist to prevent multiple instances and overlapping sounds
                if (highSynth) highSynth.dispose();
                if (melodySynth) melodySynth.dispose();
                if (bassSynth) bassSynth.dispose();
                if (highPart) highPart.dispose();     
                if (melodyPart) melodyPart.dispose(); 
                if (bassPart) bassPart.dispose();     
                
                // Stop Tone.Transport before re-initializing to clear scheduled events
                if (Tone.Transport.state === 'started') Tone.Transport.stop(); 

                // Setup High Synth (Top Treble Clef)
                highSynth = new Tone.Synth({
                    oscillator: { type: "triangle" }, // Smooth, non-intrusive waveform
                    envelope: { attack: 0.5, decay: 0.1, sustain: 0.9, release: 0.5 }
                }).toDestination();
                highSynth.volume.value = -35; // Very subtle volume

                // Setup Melody Synth (Middle Treble Clef - Arpeggio)
                melodySynth = new Tone.PolySynth(Tone.Synth, {
                    oscillator: { type: "sawtooth" }, // Classic synth sound
                    envelope: { attack: 0.05, decay: 0.1, sustain: 0.2, release: 0.5 }
                }).toDestination();
                melodySynth.volume.value = -30; // Subtle, but audible for the melody

                // Setup Bass Synth (Bottom Bass Clef)
                bassSynth = new Tone.Synth({
                    oscillator: { type: "square" }, // Deep, resonant bass
                    envelope: { attack: 0.1, decay: 0.2, sustain: 0.9, release: 0.5 }
                }).toDestination();
                bassSynth.volume.value = -31; // Volume reduced by half (approx -6dB from -25dB) for background

                // Define the note events for each part based on the sheet music
                const highNotes = [
                    { time: "0:0:0", note: "G5", duration: "4m" },
                    { time: "1:0:0", note: "C6", duration: "4m" },
                    { time: "2:0:0", note: "E6", duration: "4m" },
                    { time: "3:0:0", note: "G5", duration: "4m" }
                ];

                const melodyNotes = [
                    // Measure 1 (C Major Arpeggio)
                    { time: "0:0:0", note: "C4", duration: "8n" },
                    { time: "0:0:2", note: "G4", duration: "8n" },
                    { time: "0:1:0", note: "E4", duration: "8n" },
                    { time: "0:1:2", note: "C4", duration: "8n" },
                    { time: "0:2:0", note: "G4", duration: "8n" },
                    { time: "0:2:2", note: "E4", duration: "8n" },
                    { time: "0:3:0", note: "C4", duration: "8n" },
                    { time: "0:3:2", note: "G4", duration: "8n" },

                    // Measure 2 (D Major Arpeggio)
                    { time: "1:0:0", note: "D4", duration: "8n" },
                    { time: "1:0:2", note: "A4", duration: "8n" },
                    { time: "1:1:0", note: "F#4", duration: "8n" }, // F# for D major
                    { time: "1:1:2", note: "D4", duration: "8n" },
                    { time: "1:2:0", note: "A4", duration: "8n" },
                    { time: "1:2:2", note: "F#4", duration: "8n" },
                    { time: "1:3:0", note: "D4", duration: "8n" },
                    { time: "1:3:2", note: "A4", duration: "8n" },

                    // Measure 3 (E Major Arpeggio)
                    { time: "2:0:0", note: "E4", duration: "8n" },
                    { time: "2:0:2", note: "B4", duration: "8n" },
                    { time: "2:1:0", note: "G#4", duration: "8n" }, // G# for E major
                    { time: "2:1:2", note: "E4", duration: "8n" },
                    { time: "2:2:0", note: "B4", duration: "8n" },
                    { time: "2:2:2", note: "G#4", duration: "8n" },
                    { time: "2:3:0", note: "E4", duration: "8n" },
                    { time: "2:3:2", note: "B4", duration: "8n" },

                    // Measure 4 (C Major Arpeggio) - resolving back
                    { time: "3:0:0", note: "C4", duration: "8n" },
                    { time: "3:0:2", note: "G4", duration: "8n" },
                    { time: "3:1:0", note: "E4", duration: "8n" },
                    { time: "3:1:2", note: "C4", duration: "8n" },
                    { time: "3:2:0", note: "G4", duration: "8n" },
                    { time: "3:2:2", note: "E4", duration: "8n" },
                    { time: "3:3:0", note: "C4", duration: "8n" },
                    { time: "3:3:2", note: "G4", duration: "8n" }
                ];

                const bassNotes = [
                    { time: "0:0:0", note: "C2", duration: "4m" },
                    { time: "1:0:0", note: "D2", duration: "4m" },
                    { time: "2:0:0", note: "E2", duration: "4m" },
                    { time: "3:0:0", note: "C2", duration: "4m" }
                ];

                // Create Tone.Part for each voice and assign to global variables
                highPart = new Tone.Part((time, value) => {
                    highSynth.triggerAttackRelease(value.note, value.duration, time);
                }, highNotes).start(0);

                melodyPart = new Tone.Part((time, value) => {
                    melodySynth.triggerAttackRelease(value.note, value.duration, time);
                }, melodyNotes).start(0);

                bassPart = new Tone.Part((time, value) => {
                    bassSynth.triggerAttackRelease(value.note, value.duration, time);
                }, bassNotes).start(0);

                // Set Tone.Transport loop properties
                Tone.Transport.loop = true;
                Tone.Transport.loopEnd = '4m'; // The loop is 4 measures long
                Tone.Transport.bpm.value = 120; // Set a suitable tempo
            }

            // Function to play a specific sound effect
            async function playSound(name) {
              await Tone.start(); // Ensure AudioContext is running

              const synth = soundEffects[name]; 

              if (synth) { 
                const now = Tone.now(); // Get current Tone.js time

                switch (name) {
                  case 'turn':
                    // Play a short, low-pitched C2 note for a bass sound
                    synth.triggerAttackRelease("C2", "0.1", now); // Explicitly pass 'now'
                    break;
                  case 'crash':
                    synth.triggerAttackRelease("C2", "0.2", now, 0.8); 
                    break;
                  case 'levelUp':
                    synth.triggerAttackRelease("C4", "16n", now); 
                    synth.triggerAttackRelease("E4", "16n", now + 0.1); 
                    synth.triggerAttackRelease("G4", "16n", now + 0.2); 
                    break;
                  case 'gameOver':
                    synth.triggerAttackRelease("C3", "0.4", now); 
                    synth.triggerAttackRelease("A2", "0.4", now + 0.4); 
                    synth.triggerAttackRelease("F2", "0.4", now + 0.8); 
                    break;
                  case 'start':
                    synth.triggerAttackRelease("C5", "8n", now); // Explicitly pass 'now'
                    break;
                  case 'derezzed': // New sound for opponent derezzed
                    synth.triggerAttackRelease("G4", "16n", now, 0.5); // A quick, light sound
                    break;
                }
              } else {
                console.warn(`Sound effect "${name}" not found in soundEffects object.`);
              }
            }

            // --- Cycle Class ---
            class LightCycle {
                constructor(x, y, dirX, dirY, color, isPlayer = false) {
                    this.x = x;
                    this.y = y;
                    this.direction = { x: dirX, y: dirY };
                    this.color = color;
                    this.trail = [{x, y}];
                    this.isPlayer = isPlayer;
                    this.active = true; // Is the cycle still in the game?
                }

                // Moves the light cycle in its current direction and adds to its trail
                move() {
                    if (!this.active) return; // Only move if active
                    this.x += this.direction.x;
                    this.y += this.direction.y;
                    this.trail.push({ x: this.x, y: this.y });
                }

                // Checks for collisions with walls or any existing trails
                checkCollision(allGameTrails) {
                    // Wall collision
                    if (this.x < 0 || this.x >= tileCountX || this.y < 0 || this.y >= tileCountY) {
                        return true;
                    }
                    // Trail collision
                    for (const trail of allGameTrails) {
                        // Check against all segments of other trails, and all but the *last* segment of its own trail (to avoid self-collision with its head)
                        const trailToCheck = trail === this.trail ? trail.slice(0, -1) : trail;
                        for (const segment of trailToCheck) {
                            if (segment.x === this.x && segment.y === this.y) {
                                return true;
                            }
                        }
                    }
                    return false;
                }

                // Simple AI for opponents: avoids crashes and sometimes turns randomly
                updateAI(allGameTrails) {
                    if (this.isPlayer || !this.active) return;

                    // Function to check if a given position is safe
                    const isSafe = (x, y) => {
                        // Check walls
                        if (x < 0 || x >= tileCountX || y < 0 || y >= tileCountY) return false;
                        // Check trails
                        for (const trail of allGameTrails) {
                            // When checking against own trail, exclude the very last segment (current head)
                            const trailToCheck = trail === this.trail ? trail.slice(0, -1) : trail;
                            for (const segment of trailToCheck) {
                                if (segment.x === x && segment.y === y) return false;
                            }
                        }
                        return true;
                    };

                    const nextX = this.x + this.direction.x;
                    const nextY = this.y + this.direction.y;
                    const willCrashGoingStraight = !isSafe(nextX, nextY);

                    const possibleTurns = [];
                    // Determine valid turns based on current direction
                    if (this.direction.x === 0) { // Moving vertically (up/down)
                        possibleTurns.push({x: 1, y: 0}, {x: -1, y: 0}); // Can turn left or right
                    } else { // Moving horizontally (left/right)
                        possibleTurns.push({x: 0, y: 1}, {x: 0, y: -1}); // Can turn up or down
                    }
                    
                    // Filter out turns that would immediately lead to a crash
                    const safeTurns = possibleTurns.filter(turn => isSafe(this.x + turn.x, this.y + turn.y));

                    const randomTurnChance = 0.02; // Reduced random turn chance to prefer straight if safe

                    if (willCrashGoingStraight) {
                        if (safeTurns.length > 0) {
                            // If straight will crash, pick a random safe turn
                            this.direction = safeTurns[Math.floor(Math.random() * safeTurns.length)];
                        } else {
                            // If straight will crash AND no turns are safe, just pick any turn (will crash anyway)
                            // This means the AI is trapped, so so it will die
                            this.direction = possibleTurns[Math.floor(Math.random() * possibleTurns.length)];
                        }
                    } else if (Math.random() < randomTurnChance) {
                        // If straight is safe, but there's a small random chance to turn
                        if (safeTurns.length > 0) { // Only turn if there's a safe turn available
                            this.direction = safeTurns[Math.floor(Math.random() * safeTurns.length)];
                        }
                    }
                    // Else: willCrashGoingStraight is false AND Math.random() >= randomTurnChance, so continue straight (no change to direction)
                }
            }

            // --- Main Game Loop ---
            // Calls update and draw functions repeatedly based on game speed
            function gameLoop() {
                if (isGameOver) {
                    clearInterval(gameInterval); // Stop the loop if game is over
                    return;
                }
                update(); // Update game logic
                draw();   // Redraw canvas
            }

            // --- Update Game State ---
            function update() {
                // Update player's state
                if (player.active) {
                    player.move();
                    // Create a temporary array of all trails *including player's current new segment*
                    // This is used for collision detection for both player and opponents
                    const currentAllGameTrails = [player.trail, ...opponents.map(o => o.trail)];

                    if (player.checkCollision(currentAllGameTrails)) {
                        player.active = false;
                        endGame(false); // Player lost
                        return; // Stop further updates for this frame
                    }
                }
                
                // Update opponents' states
                let activeOpponents = 0;
                
                // Ensure all trails are up-to-date for AI and opponent collision checks
                // This is created here to include player's new position for opponent AI decisions and collision
                const currentAllTrails = [player.trail, ...opponents.map(o => o.trail)];

                opponents.forEach(opp => {
                    if (opp.active) {
                        // AI decides next move based on current game state
                        opp.updateAI(currentAllTrails); 
                        opp.move(); // Move the opponent
                        if (opp.checkCollision(currentAllTrails)) {
                            opp.active = false; // Opponent crashed
                            playSound('derezzed'); // Play derezzed sound for opponent crash
                            currentScore *= 2; // Double the score when an opponent is derezzed
                            updateScoreDisplay();
                        }
                    }
                    if(opp.active) activeOpponents++; // Count active opponents
                });
                
                opponentsLeftElement.textContent = `OPPONENTS: ${activeOpponents}`;
                
                // Update score based on survival time (only if player is active)
                if (player.active && !isGameOver) {
                    // Accumulate score based on time. Multiplying by gameSpeed/1000 scales points per tick
                    currentScore += (basePointsPerSecond * (gameSpeed / 1000));
                    updateScoreDisplay();
                }

                // Check win condition: player active and no opponents left
                if (activeOpponents === 0 && player.active) {
                   endGame(true); // Player won
                }
            }

            // --- Draw Everything on Canvas ---
            function draw() {
                // Clear canvas with a dark background
                ctx.fillStyle = '#000508';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Draw a subtle grid for the game arena
                ctx.strokeStyle = "rgba(0, 255, 255, 0.1)";
                ctx.lineWidth = 1;
                for (let i = 0; i <= tileCountX; i++) {
                    ctx.beginPath();
                    ctx.moveTo(i * gridSize, 0);
                    ctx.lineTo(i * gridSize, canvas.height);
                    ctx.stroke();
                }
                for (let i = 0; i <= tileCountY; i++) {
                    ctx.beginPath();
                    ctx.moveTo(0, i * gridSize);
                    ctx.lineTo(canvas.width, i * gridSize);
                    ctx.lineTo(canvas.width, i * gridSize);
                    ctx.stroke();
                }

                // Draw trails for all active light cycles
                ctx.lineWidth = gridSize - 2; // Thickness of the trail
                ctx.lineCap = 'round'; // Rounded ends for trails
                allTrails.forEach((trail, index) => {
                    // Determine which cycle this trail belongs to (player is index 0 in allTrails)
                    const cycle = index === 0 ? player : opponents[index-1];
                    // Even if a cycle is not active, its trail should remain as a wall
                    // if it's an opponent. Player's trail should remain if crashed.

                    ctx.strokeStyle = cycle.color; // Set trail color
                    ctx.shadowColor = cycle.color; // Add a glow effect
                    ctx.shadowBlur = 10;
                    ctx.beginPath();
                    // Start drawing from the first segment of the trail
                    ctx.moveTo(trail[0].x * gridSize + gridSize/2, trail[0].y * gridSize + gridSize/2);
                    // Draw lines to connect all segments in the trail
                    for(let i = 1; i < trail.length; i++) {
                        ctx.lineTo(trail[i].x * gridSize + gridSize/2, trail[i].y * gridSize + gridSize/2);
                    }
                    ctx.stroke(); // Render the trail
                });
                ctx.shadowBlur = 0; // Reset shadow for other drawings
            }

            // --- Game Flow Functions ---

            // Sets up the game for a new level
            function setupLevel() {
                isGameOver = false; // Game is now active
                const levelConfig = levels[currentLevel];
                gameSpeed = levelConfig.speed; // Set game speed for current level

                levelElement.textContent = `LEVEL: ${currentLevel + 1}`;
                updateScoreDisplay(); // Update score display
                updateLivesDisplay(); // Ensure lives display is updated here too

                // Always re-initialize player
                player = new LightCycle(Math.floor(tileCountX * 0.2), Math.floor(tileCountY / 2), 1, 0, '#00ffff', true);

                // Always re-initialize opponents for the current level
                opponents = [];
                const opponentColors = ['#ff4136', '#ff851b', '#ffd700', '#00ff80']; // More opponent colors
                for (let i = 0; i < levelConfig.opponents; i++) {
                    const x = Math.floor(tileCountX * 0.8); // Opponents start on the right
                    const y = Math.floor((tileCountY / (levelConfig.opponents + 1)) * (i + 1));
                    opponents.push(new LightCycle(x, y, -1, 0, opponentColors[i % opponentColors.length]));
                }
                
                // Aggregate all trails for collision detection and drawing
                allTrails = [player.trail, ...opponents.map(o => o.trail)];

                draw(); // Draw initial state of the grid and cycles
                
                clearInterval(gameInterval); // Clear any existing game loop
                gameInterval = setInterval(gameLoop, gameSpeed); // Start new game loop
                playSound('start'); // Play the new 'start' sound for the level

                // Set start time for survival score
                levelStartTime = Tone.now();

                // Start background music when the level begins
                if (Tone.context.state !== 'running') {
                    Tone.start().then(() => {
                        initializeBackgroundMusic();
                        Tone.Transport.start(); // Start Tone.js transport for looping music
                    });
                } else {
                    initializeBackgroundMusic();
                    Tone.Transport.start(); // Start Tone.js transport for looping music
                }
            }

            // Shows a modal message (e.g., Start, Level Clear, Game Over)
            function showMessage(title, text, buttonText, onButtonClick) {
                // Stop background music when a modal is shown (game paused/over)
                if (Tone.Transport.state === 'started') {
                    Tone.Transport.stop();
                    // Ensure all notes are released when stopping the transport to avoid lingering sounds
                    // Only call releaseAll for PolySynth (melodySynth) as it manages multiple voices
                    if (highSynth) highSynth.dispose(); 
                    if (melodySynth) melodySynth.releaseAll(); 
                    if (bassSynth) bassSynth.dispose(); 
                }

                // Ensure modal is visible
                messageModal.classList.remove('hidden');
                messageModal.classList.add('flex');

                modalTitle.textContent = title;
                modalText.textContent = text;
                // Get the modal button (it might have been replaced)
                let modalButton = document.getElementById('modalButton');
                modalButton.textContent = buttonText;
                
                // Store the callback so both button and spacebar can trigger it
                currentModalCallback = () => {
                    messageModal.classList.add('hidden'); // Hide modal when action is taken
                    onButtonClick(); // Execute the specific action
                };

                // Clone and replace the button to remove old event listeners and add a fresh one
                const newButton = modalButton.cloneNode(true);
                modalButton.parentNode.replaceChild(newButton, modalButton);
                newButton.addEventListener('click', currentModalCallback, { once: true });
            }
            
            // Initiates a new game from level 1
            function startGame() {
                loadHighScore(); // Load high score when starting new game
                currentLevel = 0; // Reset level
                currentScore = 0; // Reset current score
                playerLives = 3; // Reset lives for a new game
                scoreMultiplier = 1; // Reset score multiplier for a new game
                updateScoreDisplay(); // Update display
                updateLivesDisplay(); // Update lives display
                showMessage('ARE YOU READY?', `LEVEL ${currentLevel + 1}`, 'START', setupLevel);
            }

            // Handles the end of a game (win or lose)
            function endGame(playerWon) {
                isGameOver = true; // Set game over flag
                clearInterval(gameInterval); // Stop the game loop

                // Stop background music when game ends
                if (Tone.Transport.state === 'started') {
                    Tone.Transport.stop();
                    // Ensure all notes are released when stopping the transport to avoid lingering sounds
                    // Only call releaseAll for PolySynth (melodySynth) as it manages multiple voices
                    if (highSynth) highSynth.dispose(); 
                    if (melodySynth) melodySynth.releaseAll(); 
                    if (bassSynth) bassSynth.dispose(); 
                }

                if(playerWon) {
                    // Award points for completing the level
                    // The continuous score already includes survival. This is a bonus for winning.
                    currentScore += (currentLevel + 1) * levels[currentLevel].scoreMultiplier * 100; // Bonus for winning a level
                    updateScoreDisplay();

                    if(currentLevel < levels.length - 1) {
                        // Advance to next level if available
                        playSound('levelUp'); // Play level up sound
                        currentLevel++;
                        playerLives = 3; // Reset lives for the new level
                        scoreMultiplier = 1; // Reset multiplier for new level
                        showMessage('LEVEL CLEAR', `Prepare for Level ${currentLevel + 1}`, 'NEXT LEVEL', setupLevel);
                    } else {
                        // Player completed all levels
                        playSound('levelUp'); // Play a triumphant sound for victory
                        showMessage('VICTORY!', 'You are the champion of the grid!', 'PLAY AGAIN', startGame);
                    }
                } else {
                    // Player lost (crashed)
                    playSound('crash'); // Play crash sound immediately upon collision

                    if (playerLives > 1) { // If lives are 2 or 1
                        playerLives--;
                        updateLivesDisplay();
                        
                        // Briefly show "DERE'ZZED!" message on canvas and restart after delay
                        modalTitle.textContent = 'DEREZZED!';
                        modalText.textContent = `Lives left: ${playerLives}`;
                        messageModal.classList.remove('hidden');
                        messageModal.classList.add('flex');

                        setTimeout(() => {
                            messageModal.classList.add('hidden');
                            messageModal.classList.remove('flex');
                            setupLevel(); // Restart current level
                        }, 1500); // 1.5 second delay before restarting
                    } else { // No lives left (playerLives becomes 0)
                        playerLives--; // Set to 0
                        updateLivesDisplay();
                        playSound('gameOver'); // Play game over sound
                        showMessage('GAME OVER', 'You have been derezzed.', 'RESTART', startGame);
                        currentScore = 0;
                        scoreMultiplier = 1;
                    }
                }

                // Update high score if current score is better
                if (Math.floor(currentScore) > highScore) { // Compare floored current score
                    highScore = Math.floor(currentScore);
                    saveHighScore();
                    updateScoreDisplay(); // Update display again for new high score
                }
            }

            // --- Score Management ---

            // Loads the high score from local storage
            function loadHighScore() {
                const storedHighScore = localStorage.getItem('tronHighScore');
                if (storedHighScore !== null) {
                    highScore = parseInt(storedHighScore, 10);
                } else {
                    highScore = 0; // Default if no high score found
                }
                updateScoreDisplay();
            }

            // Saves the current high score to local storage
            function saveHighScore() {
                localStorage.setItem('tronHighScore', highScore.toString());
            }

            // Updates the score displays on the screen
            function updateScoreDisplay() {
                currentScoreElement.textContent = `SCORE: ${Math.floor(currentScore)}`; // Display as integer
                highScoreElement.textContent = `HIGH: ${highScore}`;
            }

            // Updates the lives display on the screen
            function updateLivesDisplay() {
                playerLivesElement.textContent = `LIVES: ${playerLives}`;
            }

            // --- Event Listeners ---

            // Handles keyboard input for player movement and game start
            function handleKeyDown(e) {
                // If a modal is active (game is over or paused for level start) and spacebar is pressed, trigger modal action
                if (messageModal.classList.contains('flex') && e.key === ' ') {
                    if (currentModalCallback) {
                        currentModalCallback(); // Execute the stored callback
                        e.preventDefault(); // Prevent default spacebar action (e.g., scrolling)
                    }
                    return; // Don't process other keys if modal is active
                }

                // If game is over or player is inactive, prevent movement input
                if (isGameOver || !player.active) return;
                
                // Prevent diagonal turns and reversing direction
                const oldDirection = { ...player.direction }; // Store old direction to check for actual turn
                switch (e.key) {
                    case 'ArrowUp':
                        if (player.direction.y === 0) player.direction = { x: 0, y: -1 };
                        break;
                    case 'ArrowDown':
                        if (player.direction.y === 0) player.direction = { x: 0, y: 1 };
                        break;
                    case 'ArrowLeft':
                        if (player.direction.x === 0) player.direction = { x: -1, y: 0 };
                        break;
                    case 'ArrowRight':
                        if (player.direction.x === 0) player.direction = { x: 1, y: 0 };
                        break;
                }
                // Play turn sound only if direction actually changed
                if (oldDirection.x !== player.direction.x || oldDirection.y !== player.direction.y) {
                    playSound('turn'); // Play the new 'turn' sound (bass)
                }
            }
            document.addEventListener('keydown', handleKeyDown);


            // Handle window resize to make the canvas responsive
            function resizeCanvas() {
                const gameContainer = document.querySelector('.game-container');
                // Calculate new canvas dimensions based on container width, maintaining aspect ratio
                const maxWidth = 600; // Original width
                const maxHeight = 400; // Original height
                const aspectRatio = maxWidth / maxHeight;

                let newWidth = gameContainer.offsetWidth;
                let newHeight = newWidth / aspectRatio;

                if (newHeight > window.innerHeight * 0.7) { // Limit height based on viewport for better fit
                    newHeight = window.innerHeight * 0.7;
                    newWidth = newHeight * aspectRatio;
                }

                // Ensure canvas dimensions are multiples of gridSize for clean pixel art
                canvas.width = Math.min(maxWidth, Math.floor(newWidth / gridSize) * gridSize);
                canvas.height = Math.min(maxHeight, Math.floor(newHeight / gridSize) * gridSize);

                // Recalculate tile counts based on new canvas size
                tileCountX = canvas.width / gridSize;
                tileCountY = canvas.height / gridSize;

                // Redraw the game if it's active or showing a modal to ensure correct scaling
                // Only redraw if the game is over (modal is likely visible) or if the game is active.
                // This prevents unnecessary redraws when hidden.
                if (!isGameOver || messageModal.classList.contains('flex')) {
                    draw();
                }
            }

            // Initial resize and add event listener for future resizes
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);


            // --- Initial Setup ---
            // Load high score and start the game
            loadHighScore();
            startGame();
        });
    </script>
</body>
</html>

