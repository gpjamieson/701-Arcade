<!DOCTYPE html>
<html lang="en">
<head>
   <meta charset="UTF-8">
   <meta name="viewport" content="width=device-width, initial-scale=1.0">
   <title>3D Void Runner</title>
   <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
   <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
   <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
 
   <style>
       * {
           box-sizing: border-box;
           margin: 0;
           padding: 0;
       }

       body {
           font-family: 'Press Start 2P', cursive;
           background-color: #0d0c0f; /* Very dark background */
           color: #e0e0e0;
           display: flex;
           flex-direction: column;
           justify-content: center;
           align-items: center;
           min-height: 100vh;
           text-align: center;
           overflow: hidden;
       }

       h1 {
           color: #00f0ff; /* Neon blue */
           text-shadow: 0 0 10px #00f0ff, 0 0 20px #00f0ff;
           margin-bottom: 20px;
           font-size: 2rem;
       }

       .game-container {
           position: relative;
           background: #1a1a2e; /* Dark blue-purple */
           padding: 20px;
           border-radius: 15px;
           box-shadow: 0 0 30px rgba(0, 240, 255, 0.3);
           border: 2px solid #00f0ff;
           width: 90vw;
           max-width: 840px; /* 800 + 20*2 padding */
       }

       .info-bar {
           display: flex;
           justify-content: space-between;
           font-size: 1rem;
           margin-bottom: 15px;
           padding: 0 10px;
           color: #fff;
       }
     
       #highScoreValue {
           color: #ff6384; /* Neon pink for high score */
       }
     
       #scoreValue {
           color: #00f0ff; /* Neon blue for current score */
       }

       /* This is where the 3D canvas will be injected */
       #canvas-container {
           background: #0f0f24; /* Darker play area */
           border-radius: 10px;
           border: 1px solid #333;
           /* Fixed logical resolution, scaled by CSS */
           width: 100%;
           max-width: 800px;
           margin: 0 auto;
           height: auto;
           aspect-ratio: 800 / 600;
           cursor: none;
           position: relative;
       }
     
       #canvas-container canvas {
           display: block; /* Remove extra space below canvas */
           width: 100%;
           height: 100%;
           border-radius: 10px;
       }

       /* Modal screens for Start/Game Over */
       .modal {
           position: absolute;
           top: 0;
           left: 0;
           right: 0;
           bottom: 0;
           background: rgba(0, 0, 0, 0.85);
           color: #fff;
           display: flex;
           flex-direction: column;
           justify-content: center;
           align-items: center;
           border-radius: 10px; /* Match canvas border radius */
           z-index: 10;
       }
     
       #gameOverScreen {
           display: none; /* Hidden by default */
       }
     
       .modal h2 {
           font-size: 2rem;
           color: #e94560; /* Neon pink */
           text-shadow: 0 0 10px #e94560;
           margin-bottom: 20px;
       }

       .modal p {
           font-size: 1rem;
           margin-bottom: 25px;
           line-height: 1.5;
       }

       .btn {
           font-family: 'Press Start 2P', cursive;
           font-size: 1rem;
           background: #00f0ff;
           color: #1a1a2e;
           border: none;
           padding: 15px 30px;
           border-radius: 10px;
           cursor: pointer;
           transition: all 0.2s ease;
           text-transform: uppercase;
       }

       .btn:hover {
           background: #fff;
           box-shadow: 0 0 15px #fff, 0 0 25px #fff;
       }

       /* Styles for new answer buttons */
       .answer-btn {
           font-family: 'Press Start 2P', cursive;
           font-size: 0.8rem;
           background: #1a1a2e;
           color: #00f0ff;
           border: 2px solid #00f0ff;
           padding: 10px 15px;
           border-radius: 8px;
           cursor: pointer;
           transition: all 0.2s ease;
           text-transform: uppercase;
           width: 80%;
           margin-top: 10px;
       }
     
       .answer-btn:hover {
           background: #00f0ff;
           color: #1a1a2e;
       }
     
       #answerOptions {
           display: flex;
           flex-direction: column;
           align-items: center;
           width: 100%;
       }
   </style>
</head>
<body>

   <h1>3D Void Runner</h1>

   <div class="game-container">
       <div class="info-bar">
           <span>Score: <span id="scoreValue">0</span></span>
           <span>High: <span id="highScoreValue">0</span></span>
       </div>

       <div id="canvas-container">
           <div id="startScreen" class="modal">
               <h2>3D Void Runner</h2>
               <p>Mouse/Touch or Arrow Keys to Move<br>Dodge the Red Cubes!</p>
               <button id="startButton" class="btn">Start Game</button>
           </div>

           <div id="gameOverScreen" class="modal">
               <h2>Game Over</h2>
               <p>Your Score: <span id="finalScore">0</span></p>
               <button id="restartButton" class="btn">Restart</button>
           </div>

           <div id="questionModal" class="modal" style="display: none;">
               <h2 id="questionText">Question about Solubility?</h2>
               <div id="answerOptions">
                   </div>
               <p id="feedbackText" style="margin-top: 15px; height: 1.5em;"></p>
           </div>
           
           <div id="reviveModal" class="modal" style="display: none;">
               <h2 style="color: #00f0ff;">Revive?</h2>
               <p>Use 700 points to revive?</p>
               <p>Current Score: <span id="reviveScore">0</span></p>
               <div style="display: flex; gap: 20px; margin-top: 20px;">
                   <button id="reviveButtonYes" class="btn">Yes (-700)</button>
                   <button id="reviveButtonNo" class="btn" style="background: #e94560; border-color: #e94560;">No</button>
               </div>
           </div>

       </div>
   </div>

   <script type="module">
       import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
       import { getAuth, onAuthStateChanged, signInWithCustomToken, signInAnonymously } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
       import { getFirestore, doc, getDoc, setDoc, onSnapshot, setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

       // --- DOM Elements ---
       const canvasContainer = document.getElementById('canvas-container');
       const scoreEl = document.getElementById('scoreValue');
       const highScoreEl = document.getElementById('highScoreValue');
       const startScreen = document.getElementById('startScreen');
       const gameOverScreen = document.getElementById('gameOverScreen');
       const startButton = document.getElementById('startButton');
       const restartButton = document.getElementById('restartButton');
       const finalScoreEl = document.getElementById('finalScore');

       // New Question Modal Elements
       const questionModal = document.getElementById('questionModal');
       const questionText = document.getElementById('questionText');
       const answerOptions = document.getElementById('answerOptions');
       const feedbackText = document.getElementById('feedbackText');
       
       // NEW: Revive Modal Elements
       const reviveModal = document.getElementById('reviveModal');
       const reviveButtonYes = document.getElementById('reviveButtonYes');
       const reviveButtonNo = document.getElementById('reviveButtonNo');
       const reviveScoreEl = document.getElementById('reviveScore');

       // --- Canvas Resolution ---
       const logicalWidth = 800;
       const logicalHeight = 600;
     
       // --- Firebase State ---
       let db, auth, userId;
       const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-3d-runner';
       let highScoreUnsubscribe = null;

       // --- 3D Scene (three.js) ---
       let scene, camera, renderer, clock, player, pointLight;
       let obstacles = [];
       let tunnelRings = [];
       const obstaclePoolSize = 10;
       const tunnelPoolSize = 20;

       // --- Game State ---
       let score, highScore = 0, gameRunning = false;
       let gameSpeed = 30; // Base speed, increases with score
       const playerBounds = { x: 5, y: 3.5 };
       let targetPlayerPos = { x: 0, y: 0 };
       let scoreTimer = 0; // NEW: Timer for score per second
     
       // --- Audio Synths (Tone.js) ---
       let musicLoop, passSound, failSound;

       // --- Question Bank ---
       let currentQuestion = null;
       const questions = [
           { q: "What happens when you mix sugar in water?", options: ["It floats", "It sinks", "It dissolves", "It disappears"], correct: 2 },
           { q: "What is the liquid (like water) that dissolves something called?", options: ["A solvent", "A solute", "A solid", "A gas"], correct: 0 },
           { q: "What is the solid (like sugar) that gets dissolved called?", options: ["A solute", "A solvent", "A liquid", "A cup"], correct: 0 },
           { q: "What do you call the sweet water after sugar has dissolved in it?", options: ["A mixture", "A solution", "A solid", "An element"], correct: 1 },
           { q: "If you keep adding sugar to water until no more can dissolve, the water is...", options: ["Empty", "Saturated", "Salty", "Bubbly"], correct: 1 },
           { q: "What can make sugar dissolve *faster* in water?", options: ["Making it cold", "Stirring it", "Putting it in the dark", "Adding oil"], correct: 1 },
           { q: "What happens if you mix sand in water?", options: ["It dissolves", "It turns into glass", "It does not dissolve", "It floats"], correct: 2 },
           { q: "What is a good example of a solvent?", options: ["Sugar", "Salt", "Water", "Sand"], correct: 2 }
       ];

       // ===================================
       // A: STORAGE (UPDATED)
       // ===================================

       // Try initializing Firebase, but don't break if it fails
       async function initFirebase() {
           try {
               const firebaseConfig = JSON.parse(typeof __firebase_config !== 'undefined' ? __firebase_config : '{}');
               if (firebaseConfig.apiKey) {
                   const app = initializeApp(firebaseConfig);
                   db = getFirestore(app);
                   auth = getAuth(app);
                   onAuthStateChanged(auth, async (user) => {
                       if (user) {
                           userId = user.uid;
                           loadHighScore();
                       } else {
                           await signInAnonymously(auth);
                       }
                   });
               }
           } catch (error) {
               console.log("Running in offline/local mode.");
           }
           // Load local high score immediately
           loadHighScore();
       }

       function getHighScoreRef() {
           if (!userId || !db) return null;
           return doc(db, 'artifacts', appId, 'users', userId, '3d-void-runner', 'highScore');
       }

       function loadHighScore() {
           // 1. Try Local Storage FIRST (Works everywhere)
           const localData = localStorage.getItem('voidRunnerHighScore');
           if (localData) {
               highScore = parseInt(localData);
               highScoreEl.textContent = highScore;
           }

           // 2. Try Firebase syncing if available
           const docRef = getHighScoreRef();
           if (docRef) {
               if (highScoreUnsubscribe) highScoreUnsubscribe();
               highScoreUnsubscribe = onSnapshot(docRef, (doc) => {
                   if (doc.exists()) {
                       const cloudScore = doc.data().score;
                       // Keep the highest of the two
                       if (cloudScore > highScore) {
                           highScore = cloudScore;
                           highScoreEl.textContent = highScore;
                           localStorage.setItem('voidRunnerHighScore', highScore);
                       }
                   }
               });
           }
       }

       async function saveHighScore() {
           // Only save if current score is higher
           if (score > highScore) {
               highScore = score;
               highScoreEl.textContent = highScore;
               
               // 1. Save to Local Storage
               localStorage.setItem('voidRunnerHighScore', highScore);

               // 2. Save to Firebase if available
               const docRef = getHighScoreRef();
               if (docRef) {
                   try {
                       await setDoc(docRef, { score: highScore });
                   } catch (error) {
                       console.error("Error saving to cloud:", error);
                   }
               }
           }
       }

       // ===================================
       // C: AUDIO (TONE.JS)
       // ===================================

       function initAudio() {
           passSound = new Tone.Synth({
               oscillator: { type: 'sine' },
               envelope: { attack: 0.01, decay: 0.1, sustain: 0, release: 0.1 }
           }).toDestination();
           passSound.volume.value = -10;

           failSound = new Tone.Synth({
               oscillator: { type: 'fatsawtooth' },
               envelope: { attack: 0.01, decay: 0.5, sustain: 0, release: 0.1 }
           }).toDestination();
           failSound.volume.value = -3;

           const musicSynth = new Tone.FMSynth().toDestination();
           musicSynth.volume.value = -12;
           musicLoop = new Tone.Sequence((time, note) => {
               musicSynth.triggerAttackRelease(note, '16n', time);
           }, ['C2', 'E2', 'G2', 'B2', 'C3', 'B2', 'G2', 'E2'], '8n');
         
           Tone.Transport.bpm.value = 120;
       }

       // ===================================
       // D: 3D GAME LOGIC (three.js)
       // ===================================

       function initThree() {
           scene = new THREE.Scene();
           scene.fog = new THREE.Fog(0x0f0f24, 10, 70); 

           camera = new THREE.PerspectiveCamera(75, logicalWidth / logicalHeight, 0.1, 1000);
           camera.position.z = 5;

           renderer = new THREE.WebGLRenderer({ antialias: true });
           renderer.setSize(logicalWidth, logicalHeight);
           canvasContainer.appendChild(renderer.domElement);

           clock = new THREE.Clock();

           const ambientLight = new THREE.AmbientLight(0xffffff, 0.2);
           scene.add(ambientLight);
         
           pointLight = new THREE.PointLight(0x00f0ff, 1, 100);
           pointLight.position.set(0, 0, 3);
           scene.add(pointLight);
         
           const playerGeo = new THREE.ConeGeometry(0.3, 0.8, 8);
           const playerMat = new THREE.MeshStandardMaterial({
               color: 0x00f0ff,
               emissive: 0x00f0ff,
               emissiveIntensity: 0.5,
           });
           player = new THREE.Mesh(playerGeo, playerMat);
           player.rotation.x = Math.PI / 2;
           scene.add(player);
         
           const ringGeo = new THREE.TorusGeometry(playerBounds.x + 1, 0.1, 8, 32);
           const ringMat = new THREE.MeshBasicMaterial({ color: 0x00f0ff, side: THREE.DoubleSide });
           for(let i=0; i<tunnelPoolSize; i++) {
               const ring = new THREE.Mesh(ringGeo, ringMat);
               ring.position.z = (i * 5) - 50;
               scene.add(ring);
               tunnelRings.push(ring);
           }
         
           const obsGeo = new THREE.BoxGeometry(1, 1, 1);
           const obsMat = new THREE.MeshStandardMaterial({
               color: 0xe94560,
               emissive: 0xe94560,
               emissiveIntensity: 0.5,
           });
           for(let i=0; i<obstaclePoolSize; i++) {
               const obstacle = new THREE.Mesh(obsGeo, obsMat);
               resetObstacle(obstacle);
               scene.add(obstacle);
               obstacles.push(obstacle);
           }
       }
     
       function resetObstacle(obs) {
           obs.position.x = (Math.random() - 0.5) * (playerBounds.x * 2);
           obs.position.y = (Math.random() - 0.5) * (playerBounds.y * 2);
           obs.position.z = -50 - (Math.random() * 20);
           obs.userData.passed = false;
       }
     
       function updatePlayer(delta) {
           player.position.x += (targetPlayerPos.x - player.position.x) * (delta * 10);
           player.position.y += (targetPlayerPos.y - player.position.y) * (delta * 10);
           pointLight.position.x = player.position.x;
           pointLight.position.y = player.position.y;
       }
     
       function updateObstacles(delta) {
           gameSpeed = 30 + (score / 5);
         
           for(let obs of obstacles) {
               obs.position.z += gameSpeed * delta;
             
               if(obs.position.z > -0.5 && obs.position.z < 0.5) {
                   if (Math.abs(player.position.x - obs.position.x) < 0.65 && 
                       Math.abs(player.position.y - obs.position.y) < 0.65) {
                       endGame();
                       return;
                   }
               }
             
               if(obs.position.z > camera.position.z) {
                   if (!obs.userData.passed) {
                       score++;
                       scoreEl.textContent = score;
                       obs.userData.passed = true;
                       if (score % 5 === 0) {
                           passSound.triggerAttackRelease('G5', '32n');
                       }
                   }
                   resetObstacle(obs);
               }
           }
       }
     
       function updateTunnel(delta) {
           for(let ring of tunnelRings) {
               ring.position.z += gameSpeed * delta;
               if(ring.position.z > camera.position.z) {
                   ring.position.z -= (tunnelPoolSize * 5);
               }
           }
       }
     
       function onWindowResize() {
           const containerRect = canvasContainer.getBoundingClientRect();
           if (containerRect.height === 0 || containerRect.width === 0) return;
           camera.aspect = containerRect.width / containerRect.height;
           camera.updateProjectionMatrix();
           renderer.setSize(containerRect.width, containerRect.height);
       }

       // ===================================
       // E: CONTROLS
       // ===================================
     
       function initControls() {
           window.addEventListener('mousemove', (e) => {
               const rect = canvasContainer.getBoundingClientRect();
               let x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
               let y = -(((e.clientY - rect.top) / rect.height) * 2 - 1);
               targetPlayerPos.x = Math.max(-playerBounds.x, Math.min(playerBounds.x, x * playerBounds.x));
               targetPlayerPos.y = Math.max(-playerBounds.y, Math.min(playerBounds.y, y * playerBounds.y));
           });
         
           window.addEventListener('touchmove', (e) => {
               e.preventDefault();
               const rect = canvasContainer.getBoundingClientRect();
               let x = ((e.touches[0].clientX - rect.left) / rect.width) * 2 - 1;
               let y = -(((e.touches[0].clientY - rect.top) / rect.height) * 2 - 1);
               targetPlayerPos.x = Math.max(-playerBounds.x, Math.min(playerBounds.x, x * playerBounds.x));
               targetPlayerPos.y = Math.max(-playerBounds.y, Math.min(playerBounds.y, y * playerBounds.y));
           }, { passive: false });
         
           window.addEventListener('keydown', (e) => {
               if (gameRunning) {
                   const moveSpeed = 0.5;
                   if (e.code === 'ArrowUp' || e.code === 'KeyW') {
                       targetPlayerPos.y = Math.min(playerBounds.y, targetPlayerPos.y + moveSpeed);
                   } else if (e.code === 'ArrowDown' || e.code === 'KeyS') {
                       targetPlayerPos.y = Math.max(-playerBounds.y, targetPlayerPos.y - moveSpeed);
                   } else if (e.code === 'ArrowLeft' || e.code === 'KeyA') {
                       targetPlayerPos.x = Math.max(-playerBounds.x, targetPlayerPos.x - moveSpeed);
                   } else if (e.code === 'ArrowRight' || e.code === 'KeyD') {
                       targetPlayerPos.x = Math.min(playerBounds.x, targetPlayerPos.x + moveSpeed);
                   }
               } else if (!gameRunning && e.code === 'Space') {
                   e.preventDefault();
                   if (startScreen.style.display === 'flex' || startScreen.style.display === '') {
                       startGame();
                   } else if (gameOverScreen.style.display === 'flex') {
                       startGame();
                   }
               }
           });
       }

       // ===================================
       // F: GAME FLOW
       // ===================================

       function gameLoop() {
           requestAnimationFrame(gameLoop);
           const delta = clock.getDelta();
         
           if (gameRunning) {
               scoreTimer += delta;
               if (scoreTimer >= 1.0) {
                   score++;
                   scoreEl.textContent = score;
                   scoreTimer -= 1.0;
               }
               
               updatePlayer(delta);
               updateObstacles(delta);
               updateTunnel(delta);
           }
           renderer.render(scene, camera);
       }

       function showQuestion() {
           currentQuestion = questions[Math.floor(Math.random() * questions.length)];
           questionText.textContent = currentQuestion.q;
           answerOptions.innerHTML = '';
           feedbackText.textContent = '';
         
           currentQuestion.options.forEach((option, index) => {
               const button = document.createElement('button');
               button.textContent = option;
               button.className = 'answer-btn';
               button.onclick = () => checkAnswer(index);
               answerOptions.appendChild(button);
           });
           questionModal.style.display = 'flex';
       }

       function checkAnswer(selectedIndex) {
           if (currentQuestion && selectedIndex === currentQuestion.correct) {
               feedbackText.textContent = "Correct! You can restart.";
               feedbackText.style.color = "#2ed573";
             
               setTimeout(() => {
                   questionModal.style.display = 'none';
                   gameOverScreen.style.display = 'flex';
               }, 1500);

           } else {
               feedbackText.textContent = "Incorrect. Try this one!";
               feedbackText.style.color = "#e94560";
             
               setTimeout(() => {
                   showQuestion();
               }, 1500);
           }
           // Ensure score is saved regardless of answer
           saveHighScore();
       }

       function showReviveModal() {
           reviveScoreEl.textContent = score;
           reviveModal.style.display = 'flex';
       }

       function revivePlayer() {
           if (score < 700) return;
           score -= 700;
           scoreEl.textContent = score;
           reviveModal.style.display = 'none';
           for(let obs of obstacles) {
               if (obs.position.z > -15 && obs.position.z < 10) {
                   resetObstacle(obs);
               }
           }
           Tone.Transport.start();
           musicLoop.start(0);
           gameRunning = true;
       }

       function proceedToQuestions() {
           reviveModal.style.display = 'none';
           showQuestion();
       }

       async function startGame() {
           await Tone.start();
           Tone.Transport.start();
           musicLoop.start(0);
           resetGame();
           gameRunning = true;
           startScreen.style.display = 'none';
           gameOverScreen.style.display = 'none';
           questionModal.style.display = 'none';
           reviveModal.style.display = 'none';
           setTimeout(onWindowResize, 50);
       }
     
       function resetGame() {
           score = 0;
           scoreEl.textContent = 0;
           scoreTimer = 0;
           targetPlayerPos = { x: 0, y: 0 };
           player.position.set(0, 0, 0);
           for(let obs of obstacles) {
               resetObstacle(obs);
           }
       }

       function endGame() {
           if (!gameRunning) return;
           
           // IMPORTANT: Save score immediately upon crashing
           saveHighScore();

           gameRunning = false;
           musicLoop.stop();
           failSound.triggerAttackRelease('C2', '2n');
           finalScoreEl.textContent = score;
         
           if (score >= 700) {
               showReviveModal();
           } else {
               proceedToQuestions();
           }
       }

       // --- Event Listeners ---
       startButton.addEventListener('click', startGame);
       restartButton.addEventListener('click', startGame);
       reviveButtonYes.addEventListener('click', revivePlayer);
       reviveButtonNo.addEventListener('click', proceedToQuestions);
       window.addEventListener('resize', onWindowResize);
     
       // --- Initialization ---
       initFirebase();
       initAudio();
       initThree();
       initControls();
       gameLoop();
       
   </script>
</body>
</html>
