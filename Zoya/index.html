<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Eco-Engineer (Stable)</title>
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Silkscreen:wght@400;700&display=swap" rel="stylesheet">
    
    <style>
        body {
            font-family: 'Silkscreen', sans-serif;
            background-color: #0A2342;
            color: #ffffff;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            image-rendering: pixelated;
            overflow: hidden;
        }

        .container {
            background-color: #0F360F;
            width: 90%;
            max-width: 600px;
            padding: 20px;
            box-sizing: border-box;
            border: 4px solid #0A300A;
            border-right-color: #052405;
            border-radius: 4px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
            text-align: center;
            position: relative;
            z-index: 10;
        }

        /* Ensure these are hidden by default */
        #main-menu, #difficulty-menu, #game-container {
            display: none; 
        }

        /* Titles */
        h1 { color: #ffcc00; font-size: 2.2em; margin-bottom: 30px; }
        h2 { color: #f0f0f0; margin-top: 0; font-size: 1.8em; }
        h3 { color: #ffcc00; font-size: 1.2em; margin: 10px 0; }

        /* Buttons */
        .button-container { display: flex; flex-direction: column; gap: 15px; }
        
        button {
            font-family: 'Silkscreen', sans-serif;
            font-size: 1em;
            padding: 16px;
            background-color: #C4DEF3;
            color: #0F360F;
            border: 3px solid #0A300A;
            box-shadow: 4px 4px 0px #9ECAEB;
            border-radius: 4px;
            cursor: pointer;
            transition: none;
            position: relative;
        }
        
        button:hover { background-color: #9ECAEB; }
        button:active { box-shadow: none; transform: translate(4px, 4px); }
        button:disabled { background-color: #999999; border-color: #666666; box-shadow: 4px 4px 0px #777777; cursor: not-allowed; }
        
        button.locked { background-color: #7A6F5D; color: #0F360F; box-shadow: 4px 4px 0px #5a5245; cursor: not-allowed; }

        /* Game Elements */
        #score-display { font-size: 1.1em; font-weight: bold; margin-bottom: 20px; text-align: left; display: flex; justify-content: space-between; }
        #combo-display { color: #ffcc00; }
        
        #timer-bar-container { width: 100%; height: 10px; background-color: #052405; border: 2px solid #0A300A; border-radius: 2px; margin-bottom: 15px; }
        #timer-bar { width: 100%; height: 100%; background-color: #89e871; transition: width 0.1s linear; }

        #options-container { display: flex; flex-direction: column; gap: 12px; }
        
        #feedback-text { font-size: 1em; line-height: 1.6; font-weight: bold; min-height: 50px; margin-top: 25px; }
        .correct { color: #89e871; } 
        .incorrect { color: #f57a7a; }

        /* Confetti Particles */
        .particle {
            position: fixed;
            width: 8px;
            height: 8px;
            pointer-events: none;
            z-index: 100;
        }

        /* Animations */
        @keyframes shake {
          0% { transform: translate(1px, 1px); }
          10% { transform: translate(-2px, -3px); }
          20% { transform: translate(-4px, 0px); }
          30% { transform: translate(3px, 2px); }
          40% { transform: translate(1px, -1px); }
          50% { transform: translate(-1px, 3px); }
          60% { transform: translate(-3px, 1px); }
          70% { transform: translate(4px, 1px); }
          80% { transform: translate(-2px, -1px); }
          90% { transform: translate(2px, 2px); }
          100% { transform: translate(0, 0); }
        }
        .shake { animation: shake 0.5s; }

    </style>
</head>
<body>

    <div id="main-menu" class="container">
        <h1>Eco-Engineer</h1>
        <button id="start-button">Start Game</button>
    </div>
    
    <div id="difficulty-menu" class="container">
        <h2>Select Difficulty</h2>
        <div class="button-container">
            <button id="easy-button">Easy</button>
            <button id="medium-button">Medium</button>
            <button id="hard-button">Hard</button>
        </div>
        <p id="high-score" style="color: #ffcc00; margin-top: 20px;">High Score: 0</p>
    </div>

    <div id="game-container" class="container">
        <div id="timer-bar-container"><div id="timer-bar"></div></div>
        
        <div id="score-display">
            <span id="score-val">Score: 0</span>
            <span id="combo-display">Combo: x1</span>
        </div>
        
        <h3 id="scenario-title"></h3>
        <p id="challenge-text"></p>
        <div id="options-container"></div>
        <p id="feedback-text"></p>
    </div>

    <script>
        // --- 1. Synthesized Audio Setup (No external files!) ---
        let audioCtx;

        function initAudio() {
            // Create audio context if it doesn't exist
            if (!audioCtx) {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            }
        }

        function play8BitClick() {
            if (!audioCtx) initAudio();
            if (audioCtx.state === 'suspended') audioCtx.resume();

            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();

            oscillator.type = 'square'; // 8-bit sound wave
            oscillator.frequency.setValueAtTime(400, audioCtx.currentTime);
            oscillator.frequency.exponentialRampToValueAtTime(100, audioCtx.currentTime + 0.1);

            gainNode.gain.setValueAtTime(0.1, audioCtx.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);

            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);

            oscillator.start();
            oscillator.stop(audioCtx.currentTime + 0.1);
        }

        // --- 2. Game Data ---
        const allLevels = {
            easy: [
                {
                    scenario: "Problem: Polluted River",
                    challenge: "A river is full of large, floating trash (bottles, bags). Which technique can remove this solid trash from the water?",
                    options: ["Evaporation", "Sieving (Screening)", "Magnetism"],
                    correctOption: "Sieving (Screening)",
                    correctFeedback: "Correct! Screens act like giant sieves.",
                    incorrectFeedback: "Not quite. That method won't catch large floating trash.",
                    hint: "Think about how you'd separate spaghetti from cooking water."
                },
                {
                    scenario: "Problem: Beach Contamination",
                    challenge: "A beach's sand is mixed with sharp iron scraps. What's the best way to separate the iron from the sand?",
                    options: ["Magnetism", "Filtration", "Sieving"],
                    correctOption: "Magnetism",
                    correctFeedback: "Yes! A giant magnet pulls out the iron.",
                    incorrectFeedback: "Try again. That won't separate iron from sand.",
                    hint: "Which of these methods uses a special force to pull *only* the iron?"
                },
                {
                    scenario: "Problem: Oil Spill",
                    challenge: "An oil tanker spilled oil. The oil is floating on top of the water. How do we separate them?",
                    options: ["Skimming (Floating)", "Magnetism", "Filtration"],
                    correctOption: "Skimming (Floating)",
                    correctFeedback: "Right! Oil floats and can be skimmed off.",
                    incorrectFeedback: "That won't work. Oil clogs filters and isn't magnetic.",
                    hint: "What does oil do when it's in water? Does it mix in, or does it float?"
                }
            ],
            medium: [
                {
                    scenario: "Problem: Water Scarcity",
                    challenge: "A town only has salty ocean water. Which technique can remove the *dissolved* salt?",
                    options: ["Filtration", "Evaporation", "Sieving"],
                    correctOption: "Evaporation",
                    correctFeedback: "Great job! Evaporation leaves the salt behind.",
                    incorrectFeedback: "The salt is dissolved, so it's too small for filters.",
                    hint: "If you leave a cup of salt water in the sun, what disappears?"
                },
                {
                    scenario: "Problem: Garden Soil",
                    challenge: "You have soil mixed with large pebbles. How can you separate the pebbles from the fine soil?",
                    options: ["Sieving", "Magnetism", "Evaporation"],
                    correctOption: "Sieving",
                    correctFeedback: "Correct! A sieve lets soil through but stops pebbles.",
                    incorrectFeedback: "That method won't work for two solids.",
                    hint: "You need something with holes bigger than soil but smaller than pebbles."
                },
                {
                    scenario: "Problem: Muddy Water",
                    challenge: "Flood water is full of fine mud. How can you separate the clear water?",
                    options: ["Filtration", "Sieving", "Magnetism"],
                    correctOption: "Filtration",
                    correctFeedback: "Right! A filter has tiny holes to trap the mud.",
                    incorrectFeedback: "A sieve's holes are too big for mud.",
                    hint: "This method uses a material with tiny holes, like a coffee filter."
                }
            ],
            hard: [
                {
                    scenario: "Problem: Messy Workshop (Step 1)",
                    challenge: "Iron bolts, sand, and pebbles are mixed. What is the *FIRST* step to separate the iron?",
                    options: ["Magnetism", "Sieving", "Filtration"],
                    correctOption: "Magnetism",
                    correctFeedback: "Exactly! Use a magnet first to grab the iron.",
                    incorrectFeedback: "Not the best *first* step.",
                    hint: "One of these materials is special. A magnet can pull it."
                },
                {
                    scenario: "Problem: Messy Workshop (Step 2)",
                    challenge: "Iron is gone. Now you have sand and pebbles. How do you separate them?",
                    options: ["Sieving", "Filtration", "Evaporation"],
                    correctOption: "Sieving",
                    correctFeedback: "Smart! A sieve traps pebbles and lets sand pass.",
                    incorrectFeedback: "That won't work for rocks and sand.",
                    hint: "How do you separate big rocks from small sand?"
                }
            ]
        };

        // --- 3. Variables ---
        let currentLevelIndex = 0;
        let score = 0;
        let combo = 1;
        let maxUnlockedDifficulty = 0;
        let currentDifficultyLevels = [];
        let highScore = localStorage.getItem('ecoHighScore') || 0;
        let timerInterval;
        let timeRemaining; 
        let difficultyIndex = 0;
        const QUESTION_TIME = 10000; 

        // --- 4. Elements ---
        const mainMenu = document.getElementById("main-menu");
        const startButton = document.getElementById("start-button");
        const difficultyMenu = document.getElementById("difficulty-menu");
        const easyButton = document.getElementById("easy-button");
        const mediumButton = document.getElementById("medium-button");
        const hardButton = document.getElementById("hard-button");
        const highScoreDisplay = document.getElementById("high-score");
        const gameContainer = document.getElementById("game-container");
        const timerBar = document.getElementById("timer-bar");
        const scenarioTitle = document.getElementById("scenario-title");
        const challengeText = document.getElementById("challenge-text");
        const optionsContainer = document.getElementById("options-container");
        const feedbackText = document.getElementById("feedback-text");
        const scoreVal = document.getElementById("score-val");
        const comboDisplay = document.getElementById("combo-display");

        // --- 5. Helper Functions ---
        function shuffleArray(array) {
            let currentIndex = array.length, randomIndex;
            while (currentIndex != 0) {
                randomIndex = Math.floor(Math.random() * currentIndex);
                currentIndex--;
                [array[currentIndex], array[randomIndex]] = [array[randomIndex], array[currentIndex]];
            }
            return array;
        }

        // --- 6. Effects ---
        function spawnConfetti(x, y) {
            const colors = ['#ffcc00', '#89e871', '#C4DEF3', '#ffffff'];
            for (let i = 0; i < 20; i++) {
                const particle = document.createElement('div');
                particle.classList.add('particle');
                particle.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
                particle.style.left = x + 'px';
                particle.style.top = y + 'px';
                document.body.appendChild(particle);

                const angle = Math.random() * Math.PI * 2;
                const velocity = Math.random() * 100 + 50;
                const tx = Math.cos(angle) * velocity;
                const ty = Math.sin(angle) * velocity;

                particle.animate([
                    { transform: 'translate(0,0) scale(1)', opacity: 1 },
                    { transform: `translate(${tx}px, ${ty}px) scale(0)`, opacity: 0 }
                ], {
                    duration: 800,
                    easing: 'cubic-bezier(0, .9, .57, 1)',
                }).onfinish = () => particle.remove();
            }
        }

        // --- 7. Core Logic ---
        function showDifficultyMenu() {
            mainMenu.style.display = "none";
            gameContainer.style.display = "none"; 
            difficultyMenu.style.display = "block"; 
            
            highScore = localStorage.getItem('ecoHighScore') || 0;
            highScoreDisplay.textContent = `High Score: ${highScore}`;
            
            if (maxUnlockedDifficulty < 1) { mediumButton.classList.add("locked"); mediumButton.disabled = true; }
            else { mediumButton.classList.remove("locked"); mediumButton.disabled = false; }
            if (maxUnlockedDifficulty < 2) { hardButton.classList.add("locked"); hardButton.disabled = true; }
            else { hardButton.classList.remove("locked"); hardButton.disabled = false; }
        }

        function startGame(index) {
            mainMenu.style.display = "none";
            difficultyMenu.style.display = "none";
            gameContainer.style.display = "block";
            
            let levels = (index === 0) ? allLevels.easy : (index === 1) ? allLevels.medium : allLevels.hard;
            currentDifficultyLevels = shuffleArray([...levels]);
            
            currentLevelIndex = 0;
            score = 0;
            combo = 1;
            updateScoreDisplay();
            loadLevel(currentDifficultyLevels[currentLevelIndex]);
        }
        
        function updateScoreDisplay() {
            scoreVal.textContent = `Score: ${score}`;
            comboDisplay.textContent = `Combo: x${combo}`;
            comboDisplay.style.color = combo > 1 ? '#ffcc00' : '#ffffff';
        }

        function startTimer() {
            timeRemaining = 100;
            timerBar.style.width = '100%';
            timerBar.style.backgroundColor = '#89e871';
            clearInterval(timerInterval);
            timerInterval = setInterval(() => {
                timeRemaining -= 1; 
                if(timeRemaining < 30) timerBar.style.backgroundColor = '#f57a7a';
                if (timeRemaining <= 0) { timeRemaining = 0; clearInterval(timerInterval); }
                timerBar.style.width = `${timeRemaining}%`;
            }, 100);
        }

        function loadLevel(level) {
            scenarioTitle.textContent = level.scenario;
            challengeText.textContent = level.challenge;
            feedbackText.textContent = "";
            optionsContainer.innerHTML = "";
            startTimer();
            level.options.forEach(option => {
                const button = document.createElement("button");
                button.textContent = option;
                button.onclick = (e) => {
                    play8BitClick();
                    checkAnswer(option, button, e.clientX, e.clientY);
                }
                optionsContainer.appendChild(button);
            });
        }

        function checkAnswer(selectedOption, clickedButton, mouseX, mouseY) {
            clearInterval(timerInterval);
            const level = currentDifficultyLevels[currentLevelIndex];
            const buttons = optionsContainer.querySelectorAll("button");
            buttons.forEach(btn => btn.disabled = true);

            if (selectedOption === level.correctOption) {
                spawnConfetti(mouseX, mouseY);
                
                let timeBonus = Math.floor(timeRemaining / 10);
                let points = (10 + timeBonus) * combo;
                score += points;
                
                feedbackText.textContent = `${level.correctFeedback} (+${points} pts!)`;
                if(combo > 1) feedbackText.textContent += ` COMBO x${combo}!`;
                
                combo++;
                feedbackText.className = "correct";
                clickedButton.style.backgroundColor = "#1B450E";
                
                setTimeout(() => {
                    currentLevelIndex++;
                    if (currentLevelIndex < currentDifficultyLevels.length) {
                        updateScoreDisplay();
                        loadLevel(currentDifficultyLevels[currentLevelIndex]);
                    } else {
                        endGame();
                    }
                }, 2000);

            } else {
                gameContainer.classList.add('shake');
                combo = 1;
                
                feedbackText.textContent = level.incorrectFeedback;
                feedbackText.className = "incorrect";
                clickedButton.style.backgroundColor = "#940F0F";
                
                setTimeout(() => gameContainer.classList.remove('shake'), 500);
                setTimeout(() => {
                    feedbackText.textContent = "Hint: " + level.hint;
                    feedbackText.className = "";
                    buttons.forEach(btn => {
                        btn.disabled = false;
                        btn.style.backgroundColor = "#C4DEF3";
                    });
                    updateScoreDisplay();
                }, 2000);
            }
            updateScoreDisplay();
        }

        function endGame() {
            if (score > highScore) {
                highScore = score;
                localStorage.setItem('ecoHighScore', highScore);
                feedbackText.textContent = "NEW HIGH SCORE!";
            } else {
                feedbackText.textContent = "Good job!";
            }
            
            if (difficultyIndex === 0 && maxUnlockedDifficulty < 1) maxUnlockedDifficulty = 1;
            if (difficultyIndex === 1 && maxUnlockedDifficulty < 2) maxUnlockedDifficulty = 2;

            scenarioTitle.textContent = "Stage Clear!";
            challengeText.textContent = `Final Score: ${score}`;
            optionsContainer.innerHTML = "";
            
            const backButton = document.createElement("button");
            backButton.textContent = "Back to Menu";
            backButton.onclick = () => { 
                play8BitClick(); 
                showDifficultyMenu(); 
            };
            optionsContainer.appendChild(backButton);
        }

        // --- 8. Initialization ---
        document.addEventListener('DOMContentLoaded', () => {
            mainMenu.style.display = "block";
            
            startButton.addEventListener('click', () => {
                initAudio(); // Prepare audio system
                play8BitClick();
                showDifficultyMenu();
            });

            [easyButton, mediumButton, hardButton].forEach((btn, index) => {
                btn.addEventListener('click', () => {
                    play8BitClick();
                    if (!btn.disabled) {
                        difficultyIndex = index;
                        startGame(index);
                    }
                });
            });
        });

    </script>
</body>
</html>
